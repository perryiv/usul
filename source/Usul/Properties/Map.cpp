
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2019, Perry L Miller IV
//  All rights reserved.
//  MIT License: https://opensource.org/licenses/mit-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Map of properties.
//
///////////////////////////////////////////////////////////////////////////////

#include "Usul/Properties/Map.h"
#include "Usul/Tools/NoThrow.h"

#include <functional>


namespace Usul {
namespace Properties {


///////////////////////////////////////////////////////////////////////////////
//
//  Constructors
//
///////////////////////////////////////////////////////////////////////////////

Map::Map() :
  _values()
{
}
Map::Map ( const Map &m ) :
  _values ( m._values )
{
}
Map::Map ( const Map::Values &values ) :
  _values ( values )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
///////////////////////////////////////////////////////////////////////////////

Map::~Map()
{
  USUL_TOOLS_NO_THROW ( 1568933604, std::bind ( &Map::_destroyMap, this ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Assignment
//
///////////////////////////////////////////////////////////////////////////////

Map &Map::operator = ( const Map &m )
{
  _values = m._values;
  return *this;
}
Map &Map::operator = ( const Map::Values &values )
{
  _values = values;
  return *this;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destroy
//
///////////////////////////////////////////////////////////////////////////////

void Map::_destroyMap()
{
  _values.clear();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the property object.
//
///////////////////////////////////////////////////////////////////////////////

const Map::Object *Map::object ( const std::string &name ) const
{
  Values::const_iterator i = _values.find ( name );
  return ( ( _values.end() == i ) ? nullptr : i->second.get() );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Clear the map.
//
///////////////////////////////////////////////////////////////////////////////

void Map::clear()
{
  _values.clear();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Erase the property.
//
///////////////////////////////////////////////////////////////////////////////

bool Map::erase ( const std::string &name )
{
  Values::iterator i = _values.find ( name );
  if ( _values.end() != i )
  {
    _values.erase ( i );
    return true;
  }
  return false;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Is there a property with this name?
//
///////////////////////////////////////////////////////////////////////////////

bool Map::has ( const std::string &name ) const
{
  return ( _values.end() != _values.find ( name ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Insert the value.
//
///////////////////////////////////////////////////////////////////////////////

void Map::insert ( const std::string &name, const std::string &value )
{
  this->insert < std::string > ( name, value );
}
void Map::insert ( const std::string &name, const char *value )
{
  this->insert ( name, std::string ( value ) );
}
void Map::insert ( const std::string &name, std::nullptr_t value )
{
  this->insert < std::nullptr_t > ( name, value );
}
void Map::insert ( const std::string &name, Object::RefPtr value )
{
  _values.insert ( Values::value_type ( name, value ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Insert or update the value.
//
///////////////////////////////////////////////////////////////////////////////

void Map::update ( const std::string &name, const std::string &value )
{
  this->update < std::string > ( name, value );
}
void Map::update ( const std::string &name, const char *value )
{
  this->update ( name, std::string ( value ) );
}
void Map::update ( const std::string &name, std::nullptr_t value )
{
  this->update < std::nullptr_t > ( name, value );
}
void Map::update ( const std::string &name, Object::RefPtr value )
{
  _values[name] = value;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the type of the property.
//
///////////////////////////////////////////////////////////////////////////////

std::string Map::type ( const std::string &key ) const
{
  const Object *obj = this->object ( key );

  if ( nullptr != obj )
  {
    const std::type_info &info = obj->getTypeInfo();
    const char *name = info.name();
    if ( nullptr != name )
    {
      return std::string ( name );
    }
  }

  return std::string();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the names.
//
///////////////////////////////////////////////////////////////////////////////

void Map::names ( Strings &s ) const
{
  typedef Values::const_iterator Itr;
  for ( Itr i = _values.begin(); i != _values.end(); ++i )
  {
    s.push_back ( i->first );
  }
}
Map::Strings Map::names() const
{
  Strings s;
  s.reserve ( _values.size() );
  this->names ( s );
  return s;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Merge the properties.
//
///////////////////////////////////////////////////////////////////////////////

void Map::merge ( const Map &source )
{
  this->merge ( source.values() );
}
void Map::merge ( const Map::Values &source )
{
  typedef Map::Values::const_iterator Itr;
  typedef Map::Values::key_type Key;

  for ( Itr i = source.begin(); i != source.end(); ++i )
  {
    const Key &key = i->first;
    _values[key] = i->second;
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the value.
//
///////////////////////////////////////////////////////////////////////////////

Object::RefPtr Map::get ( const std::string &name ) const
{
  return Object::RefPtr ( const_cast < Object * > ( this->object ( name ) ) );
}


} // namespace Properties
} // namespace Usul
