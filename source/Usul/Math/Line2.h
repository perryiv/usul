
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2009, 2019, Perry L Miller IV
//  All rights reserved.
//  MIT License: https://opensource.org/licenses/mit-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  2D line class.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _USUL_MATH_LINE_2D_H_
#define _USUL_MATH_LINE_2D_H_

#include "Usul/Errors/Check.h"
#include "Usul/Math/Vector2.h"

#include <stdexcept>


namespace Usul {
namespace Math {


template
<
  typename T,
  typename IndexType = unsigned int
>
class Line2
{
public:

  /////////////////////////////////////////////////////////////////////////////
  //
  //  Useful typedefs.
  //
  /////////////////////////////////////////////////////////////////////////////

  typedef T value_type;
  typedef IndexType size_type;
  typedef Line2 < T, IndexType > ThisType;
  typedef Usul::Math::Vector2 < T > Vec;
  typedef Vec Point;


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Default constructor.
  //
  /////////////////////////////////////////////////////////////////////////////

  Line2() :
    _p0 ( 0,  0 ),
    _p1 ( 0, -1 )
  {
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Constructor.
  //
  /////////////////////////////////////////////////////////////////////////////

  Line2 ( const Point &p0, const Point &p1 ) :
    _p0 ( p0 ),
    _p1 ( p1 )
  {
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Copy constructor.
  //
  /////////////////////////////////////////////////////////////////////////////

  Line2 ( const Line2 &line ) :
    _p0 ( line._p0 ),
    _p1 ( line._p1 )
  {
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Set the value.
  //
  /////////////////////////////////////////////////////////////////////////////

  void set ( const Line2 &line )
  {
    _p0.set ( line._p0 );
    _p1.set ( line._p1 );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Set the value.
  //
  /////////////////////////////////////////////////////////////////////////////

  void set ( const Point &p0, const Point &p1 )
  {
    _p0.set ( p0 );
    _p1.set ( p1 );
  }


  ///////////////////////////////////////////////////////////////////////////////
  //
  //  Set the line from an origin and direction.
  //
  ///////////////////////////////////////////////////////////////////////////////

  void setFromOriginAndDirection ( const Point &pt, const Vec &dir )
  {
    this->set ( pt, Usul::Math::add ( pt, dir ) );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Return the origin.
  //
  /////////////////////////////////////////////////////////////////////////////

  const Point &getOrigin() const
  {
    return _p0;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Return the direction vector.
  //
  /////////////////////////////////////////////////////////////////////////////

  Point getDirection() const
  {
    return Usul::Math::subtract ( _p1, _p0 );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Return a unit direction vector.
  //
  /////////////////////////////////////////////////////////////////////////////

  Point getUnitDirection() const
  {
    return Usul::Math::normalize ( this->getDirection() );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Bracket operators.
  //
  /////////////////////////////////////////////////////////////////////////////

  Point &operator [] ( size_type i )
  {
    USUL_CHECK_INDEX_RANGE ( 2, i, "Index out of range in Line2 [] operator" );
    return ( ( 0 == i ) ? _p0 : _p1 );
  }
  const Point &operator [] ( size_type i ) const
  {
    USUL_CHECK_INDEX_RANGE ( 2, i, "Index out of range in Line2 [] operator" );
    return ( ( 0 == i ) ? _p0 : _p1 );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Return true if the lines are equal.
  //
  /////////////////////////////////////////////////////////////////////////////

  static bool equal ( const Line2 &a, const Line2 &b )
  {
    const Point &a0 ( a[0] );
    const Point &a1 ( a[1] );

    const Point &b0 ( b[0] );
    const Point &b1 ( b[1] );

    return (
      ( ( a0[0] == b0[0] ) && ( a0[1] == b0[1] ) ) &&
      ( ( a1[0] == b1[0] ) && ( a1[1] == b1[1] ) )
    );
  }


private:

  Point _p0;
  Point _p1;
};


/////////////////////////////////////////////////////////////////////////////
//
//  Return true if the lines are equal.
//
/////////////////////////////////////////////////////////////////////////////

template < class T >
inline bool equal ( const Line2 < T > &a, const Line2 < T > &b )
{
  typedef Line2 < T > LineType;
  return ( LineType::equal ( a, b ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Useful typedefs.
//
///////////////////////////////////////////////////////////////////////////////

typedef Line2 < float          > Line2f;
typedef Line2 < double         > Line2d;
typedef Line2 < long double    > Line2ld;


} // namespace Math
} // namespace Usul


#endif // _USUL_MATH_LINE_2D_H_
