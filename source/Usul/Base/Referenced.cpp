
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2019, Perry L Miller IV
//  All rights reserved.
//  MIT License: https://opensource.org/licenses/mit-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Reference-counting base class.
//
///////////////////////////////////////////////////////////////////////////////

#include "Usul/Base/Referenced.h"
#include "Usul/Errors/Handler.h"
#include "Usul/Strings/Format.h"


namespace Usul {
namespace Base {


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Referenced::Referenced() : BaseClass(),
  _refCount ( 0 )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Referenced::Referenced ( const Referenced &r ) : BaseClass ( r ),
  _refCount ( 0 )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Referenced::~Referenced()
{
  // Should be true.
  USUL_ERROR_CHECKER_NO_THROW ( 0 == _refCount );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Assignment.
//
///////////////////////////////////////////////////////////////////////////////

Referenced &Referenced::operator = ( const Referenced & )
{
  // We define this function to make sure the compiler does not.
  // A compiler-generated operator would probably assign the reference count,
  // which does not make any sense.
  return *this;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Classes that inherit can overload and return an IUnknown.
//
///////////////////////////////////////////////////////////////////////////////

Usul::Interfaces::IUnknown *Referenced::asUnknown()
{
	return nullptr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Reference this instance.
//
///////////////////////////////////////////////////////////////////////////////

void Referenced::ref()
{
  ++_refCount;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Dereference this instance.
//
///////////////////////////////////////////////////////////////////////////////

void Referenced::unref ( bool allowDeletion )
{
  if ( ( 0 == --_refCount ) && allowDeletion )
  {
    this->_deleteMe();
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the reference count.
//
///////////////////////////////////////////////////////////////////////////////

Referenced::CounterType Referenced::getReferenceCount() const
{
  return _refCount;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Delete this instance.
//
///////////////////////////////////////////////////////////////////////////////

void Referenced::_deleteMe()
{
#ifdef _DEBUG

  const Referenced *self = nullptr;
  const char *name = nullptr;

  try
  {
    self = this;
    name = typeid ( *this ).name();
    delete this;
  }

  catch ( const std::exception &e )
  {
    USUL_ERROR_HANDLER ( Usul::Strings::format (
      "Deleting this instance caused a standard exception",
      ", Message: ", e.what(),
      ", Address: ", self,
      ", Class: ", ( name ? name : "" ) ) );
  }

  catch ( ... )
  {
    USUL_ERROR_HANDLER ( Usul::Strings::format (
      "Deleting this instance caused an unknown exception",
      ", Address: ", self,
      ", Class: ", ( name ? name : "" ) ) );
  }

#else

  delete this;

#endif
}


} // namespace Base
} // namespace Usul
